//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Indicium.Schemas {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    
    
    /// <summary>
    /// <para>
    /// Regular expression: (WhitespaceCharacters?, LineDelimiter?, Token+)
    /// </para>
    /// </summary>
    public partial class TokenContext : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<Token> TokenField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator TokenContext(XElement xe) { return XTypedServices.ToXTypedElement<TokenContext>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static TokenContext() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(System.Xml.Linq.XName.Get("WhitespaceCharacters", "")), new NamedContentModelEntity(System.Xml.Linq.XName.Get("LineDelimiter", "")), new NamedContentModelEntity(System.Xml.Linq.XName.Get("Token", "https://github.com/mamift/Indicium")));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (WhitespaceCharacters?, LineDelimiter?, Token+)
        /// </para>
        /// </summary>
        public TokenContext() {
        }
        
        /// <summary>
        /// <para>
        /// A string literal (NOT regex string) to recognise whitespace characters. Whitespace characters are not collapsed in this element, so adding a return carriage (pressing [ENTER] will be interpreted as valid input). Not specifying this element defaults to a tab and a space ([\t\s]+).
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (WhitespaceCharacters?, LineDelimiter?, Token+)
        /// </para>
        /// </summary>
        public virtual string WhitespaceCharacters {
            get {
                XElement x = this.GetElement(System.Xml.Linq.XName.Get("WhitespaceCharacters", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetElement(System.Xml.Linq.XName.Get("WhitespaceCharacters", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A custom regex string to recognise a line delimiter. Not specifying this element or giving an empty value to this element will default to the value defined in System.Environment.NewLine.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// <para>
        /// Regular expression: (WhitespaceCharacters?, LineDelimiter?, Token+)
        /// </para>
        /// </summary>
        public virtual string LineDelimiter {
            get {
                XElement x = this.GetElement(System.Xml.Linq.XName.Get("LineDelimiter", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NormalizedString).Datatype);
            }
            set {
                this.SetElementWithValidation(System.Xml.Linq.XName.Get("LineDelimiter", ""), value, "LineDelimiter", global::Indicium.Schemas.RegexString.TypeDefinition);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (WhitespaceCharacters?, LineDelimiter?, Token+)
        /// </para>
        /// </summary>
        public virtual IList<Token> Token {
            get {
                if ((this.TokenField == null)) {
                    this.TokenField = new XTypedList<Token>(this, LinqToXsdTypeManager.Instance, System.Xml.Linq.XName.Get("Token", "https://github.com/mamift/Indicium"));
                }
                return this.TokenField;
            }
            set {
                if ((value == null)) {
                    this.TokenField = null;
                }
                else {
                    if ((this.TokenField == null)) {
                        this.TokenField = XTypedList<Token>.Initialize(this, LinqToXsdTypeManager.Instance, value, System.Xml.Linq.XName.Get("Token", "https://github.com/mamift/Indicium"));
                    }
                    else {
                        XTypedServices.SetList<Token>(this.TokenField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Used only for code generation; specifies the class name.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string ClassName {
            get {
                XAttribute x = this.Attribute(System.Xml.Linq.XName.Get("ClassName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(System.Xml.Linq.XName.Get("ClassName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Used only for code generation; specify a namespace to use when generating code.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string NamespaceName {
            get {
                XAttribute x = this.Attribute(System.Xml.Linq.XName.Get("NamespaceName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(System.Xml.Linq.XName.Get("NamespaceName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Generate a public Enum type that enumerates the Tokens defined.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Nullable<bool> GenerateEnums {
            get {
                XAttribute x = this.Attribute(System.Xml.Linq.XName.Get("GenerateEnums", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
            set {
                this.SetAttribute(System.Xml.Linq.XName.Get("GenerateEnums", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Determines the generated types visiblity: public or internal. Unrecognised values default to public.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string Visibility {
            get {
                XAttribute x = this.Attribute(System.Xml.Linq.XName.Get("Visibility", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(System.Xml.Linq.XName.Get("Visibility", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return System.Xml.Linq.XName.Get("TokenContext", "https://github.com/mamift/Indicium");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static TokenContext Load(string xmlFile) {
            return XTypedServices.Load<TokenContext>(xmlFile);
        }
        
        public static TokenContext Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<TokenContext>(xmlFile);
        }
        
        public static TokenContext Parse(string xml) {
            return XTypedServices.Parse<TokenContext>(xml);
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<TokenContext>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(System.Xml.Linq.XName.Get("WhitespaceCharacters", ""), typeof(string));
            localElementDictionary.Add(System.Xml.Linq.XName.Get("LineDelimiter", ""), typeof(string));
            localElementDictionary.Add(System.Xml.Linq.XName.Get("Token", "https://github.com/mamift/Indicium"), typeof(Token));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    public partial class Lexeme : XTypedElement, IXMetaData {
        
		public static explicit operator Lexeme(XElement xe) { return XTypedServices.ToXTypedElement<Lexeme>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public Lexeme() {
        }
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string Id {
            get {
                XAttribute x = this.Attribute(System.Xml.Linq.XName.Get("Id", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(System.Xml.Linq.XName.Get("Id", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual int LineNumber {
            get {
                XAttribute x = this.Attribute(System.Xml.Linq.XName.Get("LineNumber", ""));
                return XTypedServices.ParseValue<int>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int).Datatype);
            }
            set {
                this.SetAttribute(System.Xml.Linq.XName.Get("LineNumber", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual int LineIndex {
            get {
                XAttribute x = this.Attribute(System.Xml.Linq.XName.Get("LineIndex", ""));
                return XTypedServices.ParseValue<int>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int).Datatype);
            }
            set {
                this.SetAttribute(System.Xml.Linq.XName.Get("LineIndex", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return System.Xml.Linq.XName.Get("Lexeme", "https://github.com/mamift/Indicium");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static Lexeme Load(string xmlFile) {
            return XTypedServices.Load<Lexeme>(xmlFile);
        }
        
        public static Lexeme Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<Lexeme>(xmlFile);
        }
        
        public static Lexeme Parse(string xml) {
            return XTypedServices.Parse<Lexeme>(xml);
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Lexeme>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Whitespace is collapsed according to XSD schema type rules for the xs:string type.
    /// </para>
    /// </summary>
    public sealed class RegexString {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NormalizedString), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(32)), null, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
        
        private RegexString() {
        }
    }
    
    /// <summary>
    /// <para>
    /// The base schema type for Tokens. Whitespace is collapsed.
    /// </para>
    /// </summary>
    public partial class TToken : XTypedElement, IXMetaData {
        
		public static explicit operator TToken(XElement xe) { return XTypedServices.ToXTypedElement<TToken>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The base schema type for Tokens. Whitespace is collapsed.
        /// </para>
        /// </summary>
        public TToken() {
        }
        
        public virtual string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NormalizedString).Datatype);
            }
            set {
                this.SetValueWithValidation(value, "TypedValue", global::Indicium.Schemas.RegexString.TypeDefinition);
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for this element. This is optional, as a Token element may actually refer to one already defined.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string Id {
            get {
                XAttribute x = this.Attribute(System.Xml.Linq.XName.Get("Id", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
            set {
                this.SetAttribute(System.Xml.Linq.XName.Get("Id", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Refer to another already defined element. Other attributes on this element will be ignored if this attribute has a value.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string @Ref {
            get {
                XAttribute x = this.Attribute(System.Xml.Linq.XName.Get("Ref", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(System.Xml.Linq.XName.Get("Ref", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A description.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string Description {
            get {
                XAttribute x = this.Attribute(System.Xml.Linq.XName.Get("Description", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(System.Xml.Linq.XName.Get("Description", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Used for code generation. This is filled by the Indicium library; specifying a value here on your own is meaningless as it will be ignored and then overwritten during code generation.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Nullable<short> @Enum {
            get {
                XAttribute x = this.Attribute(System.Xml.Linq.XName.Get("Enum", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<short>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Short).Datatype);
            }
            set {
                this.SetAttribute(System.Xml.Linq.XName.Get("Enum", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Short).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return System.Xml.Linq.XName.Get("TToken", "https://github.com/mamift/Indicium");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<TToken>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The base schema type for Tokens. Whitespace is collapsed.
    /// </para>
    /// </summary>
    public partial class Token : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private TToken ContentField;
        
		public static explicit operator Token(XElement xe) { return XTypedServices.ToXTypedElement<Token, TToken>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The base schema type for Tokens. Whitespace is collapsed.
        /// </para>
        /// </summary>
        public Token() {
            SetInnerType(new TToken());
        }
        
        /// <summary>
        /// <para>
        /// The base schema type for Tokens. Whitespace is collapsed.
        /// </para>
        /// </summary>
        public Token(TToken content) {
            SetInnerType(content);
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public virtual TToken Content {
            get {
                return ContentField;
            }
        }
        
        public virtual string TypedValue {
            get {
                return this.ContentField.TypedValue;
            }
            set {
                this.ContentField.TypedValue = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// The unique identifier for this element. This is optional, as a Token element may actually refer to one already defined.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string Id {
            get {
                return this.ContentField.Id;
            }
            set {
                this.ContentField.Id = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Refer to another already defined element. Other attributes on this element will be ignored if this attribute has a value.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string @Ref {
            get {
                return this.ContentField.@Ref;
            }
            set {
                this.ContentField.@Ref = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// A description.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string Description {
            get {
                return this.ContentField.Description;
            }
            set {
                this.ContentField.Description = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Used for code generation. This is filled by the Indicium library; specifying a value here on your own is meaningless as it will be ignored and then overwritten during code generation.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Nullable<short> @Enum {
            get {
                return this.ContentField.@Enum;
            }
            set {
                this.ContentField.@Enum = value;
            }
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return System.Xml.Linq.XName.Get("Token", "https://github.com/mamift/Indicium");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static Token Load(string xmlFile) {
            return XTypedServices.Load<Token, TToken>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static Token Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<Token, TToken>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static Token Parse(string xml) {
            return XTypedServices.Parse<Token, TToken>(xml, LinqToXsdTypeManager.Instance);
        }
        
        public override XTypedElement Clone() {
            return new Token(((TToken)(this.Content.Clone())));
        }
        
        private void SetInnerType(TToken ContentField) {
            this.ContentField = ((TToken)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    public class LinqToXsdTypeManager : ILinqToXsdTypeManager {
        
        private static Dictionary<System.Xml.Linq.XName, System.Type> typeDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static Dictionary<System.Xml.Linq.XName, System.Type> elementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static Dictionary<System.Type, System.Type> wrapperDictionary = new Dictionary<System.Type, System.Type>();
        
        private static XmlSchemaSet schemaSet;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static LinqToXsdTypeManager typeManagerSingleton = new LinqToXsdTypeManager();
        
        static LinqToXsdTypeManager() {
            BuildTypeDictionary();
            BuildElementDictionary();
            BuildWrapperDictionary();
        }
        
        XmlSchemaSet ILinqToXsdTypeManager.Schemas {
            get {
                if ((schemaSet == null)) {
                    XmlSchemaSet tempSet = new XmlSchemaSet();
                    System.Threading.Interlocked.CompareExchange(ref schemaSet, tempSet, null);
                }
                return schemaSet;
            }
            set {
                schemaSet = value;
            }
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> ILinqToXsdTypeManager.GlobalTypeDictionary {
            get {
                return typeDictionary;
            }
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> ILinqToXsdTypeManager.GlobalElementDictionary {
            get {
                return elementDictionary;
            }
        }
        
        Dictionary<System.Type, System.Type> ILinqToXsdTypeManager.RootContentTypeMapping {
            get {
                return wrapperDictionary;
            }
        }
        
        public static LinqToXsdTypeManager Instance {
            get {
                return typeManagerSingleton;
            }
        }
        
        private static void BuildTypeDictionary() {
            typeDictionary.Add(System.Xml.Linq.XName.Get("TToken", "https://github.com/mamift/Indicium"), typeof(global::Indicium.Schemas.TToken));
        }
        
        private static void BuildElementDictionary() {
            elementDictionary.Add(System.Xml.Linq.XName.Get("TokenContext", "https://github.com/mamift/Indicium"), typeof(global::Indicium.Schemas.TokenContext));
            elementDictionary.Add(System.Xml.Linq.XName.Get("Lexeme", "https://github.com/mamift/Indicium"), typeof(global::Indicium.Schemas.Lexeme));
            elementDictionary.Add(System.Xml.Linq.XName.Get("Token", "https://github.com/mamift/Indicium"), typeof(global::Indicium.Schemas.Token));
        }
        
        private static void BuildWrapperDictionary() {
            wrapperDictionary.Add(typeof(Indicium.Schemas.Token), typeof(global::Indicium.Schemas.TToken));
        }
        
        protected internal static void AddSchemas(XmlSchemaSet schemas) {
            schemas.Add(schemaSet);
        }
        
        public static System.Type GetRootType() {
            return elementDictionary[System.Xml.Linq.XName.Get("TokenContext", "https://github.com/mamift/Indicium")];
        }
    }
    
    public partial class XRootNamespace {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        

		public TokenContext TokenContext {  get {return rootObject as TokenContext; } }

		public Lexeme Lexeme {  get {return rootObject as Lexeme; } }

		public Token Token {  get {return rootObject as Token; } }
        
        private XRootNamespace() {
        }
        
        public XRootNamespace(TokenContext root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XRootNamespace(Lexeme root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XRootNamespace(Token root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public virtual XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public static XRootNamespace Load(string xmlFile) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(string xmlFile, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(XmlReader xmlReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
    }
    
    public partial class XRoot {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        

		public global::Indicium.Schemas.TokenContext TokenContext {  get {return rootObject as global::Indicium.Schemas.TokenContext; } }

		public global::Indicium.Schemas.Lexeme Lexeme {  get {return rootObject as global::Indicium.Schemas.Lexeme; } }

		public global::Indicium.Schemas.Token Token {  get {return rootObject as global::Indicium.Schemas.Token; } }
        
        private XRoot() {
        }
        
        public XRoot(global::Indicium.Schemas.TokenContext root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XRoot(global::Indicium.Schemas.Lexeme root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XRoot(global::Indicium.Schemas.Token root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public virtual XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public static XRoot Load(string xmlFile) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(string xmlFile, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(XmlReader xmlReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
    }
}
